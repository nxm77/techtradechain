// Package bloom package
package bloom

/*
Copyright (C) THL A29 Limited, a Tencent company. All rights reserved.

SPDX-License-Identifier: Apache-2.0
*/

import (
	"fmt"
	"os"
	"path"
	"time"

	storePb "techtradechain.com/techtradechain/pb-go/v2/store"
	"techtradechain.com/techtradechain/protocol/v2"
	"techtradechain.com/techtradechain/store/v2/bloom"
	"techtradechain.com/techtradechain/store/v2/conf"
	"techtradechain.com/techtradechain/store/v2/serialization"
	"techtradechain.com/techtradechain/store/v2/statedb"
)

const (
	contractStoreSeparator    = '#'
	defaultBloomDumpPerBlocks = 1000
	stateDBSavepointKey       = "stateDBSavePointKey"
)

// BloomStateDb is a bloom filter pre-installed for the underlying statedb database.
type BloomStateDb struct {
	statedb.StateDB
	filter *BloomFilter
	logger protocol.Logger
}

// NewBloomStateDb create a wrapper using bloom filter for the underlying state db.
func NewBloomStateDb(stateDB statedb.StateDB, filter *BloomFilter, logger protocol.Logger) *BloomStateDb {
	filter.Add([]byte(stateDBSavepointKey))
	return &BloomStateDb{
		StateDB: stateDB,
		filter:  filter,
		logger:  logger,
	}
}

// InitGenesis init genesis block use the underlying StateDB, if successful,
// add the write sets of the genesis block to the Bloom filter.
func (b *BloomStateDb) InitGenesis(genesisBlock *serialization.BlockWithSerializedInfo) error {
	err := b.StateDB.InitGenesis(genesisBlock)
	if err != nil {
		return err
	}
	b.filter.AddBlock(&storePb.BlockWithRWSet{
		Block:    genesisBlock.Block,
		TxRWSets: genesisBlock.TxRWSets,
	})
	return nil
}

// CommitBlock commit the block to the underlying StateDB, if successful, add all write sets of the block
// to the Bloom filter.
func (b *BloomStateDb) CommitBlock(blockWithRWSet *serialization.BlockWithSerializedInfo, isCache bool) error {
	if err := b.StateDB.CommitBlock(blockWithRWSet, isCache); err != nil {
		return err
	}
	// CommitBlock will be called twice when store puts a block.
	// First time: isCache = true, then isCache = false.
	// Please modify here if the commit logic changes.
	if !isCache {
		return nil
	}
	b.filter.AddBlock(&storePb.BlockWithRWSet{
		Block:    blockWithRWSet.Block,
		TxRWSets: blockWithRWSet.TxRWSets,
	})
	return nil
}

// ReadObject if the key exists in the Bloom filter, read from the underlying StateDB.
// Otherwise return nil.
func (b *BloomStateDb) ReadObject(contractName string, key []byte) ([]byte, error) {
	if b.filter.Has(contractName, key) {
		b.logger.Debugf("read object through db for contract:%s, key:%s", contractName, key)
		return b.StateDB.ReadObject(contractName, key)
	}
	return nil, nil
}

// ReadObjects filter the keys that exist in the Bloom filter, then pass them to the underlying StateDB.
// The keys not exist in the Bloom filter will be returned as nil.
func (b *BloomStateDb) ReadObjects(contractName string, keys [][]byte) ([][]byte, error) {
	objectKeys := make([][]byte, 0, len(keys))
	objectValues := make([][]byte, len(keys))
	nullBytes := []byte{}
	for i := 0; i < len(keys); i++ {
		if b.filter.Has(contractName, keys[i]) {
			objectKeys = append(objectKeys, keys[i])
			objectValues[i] = nullBytes
		}
	}
	if len(objectKeys) == 0 {
		return objectValues, nil
	}
	b.logger.Debugf("read objects through db for contract:%s, keys [%d/%d]",
		contractName, len(keys), len(objectKeys))
	values, err := b.StateDB.ReadObjects(contractName, objectKeys)
	if err != nil {
		return nil, err
	}
	idx := 0
	for i := range objectValues {
		if objectValues[i] != nil {
			objectValues[i] = values[idx]
			idx++
		}
	}
	return objectValues, nil
}

// Close close the underlying StateDB and dump the bloom filter data to file.
func (b *BloomStateDb) Close() {
	b.StateDB.Close()
	_ = b.filter.Close()
}

// BloomFilter wrapper of bloom.BlockBloomFilter
type BloomFilter struct {
	*bloom.BlockBloomFilter
	config *conf.BloomConfig
	logger protocol.Logger
}

// Close dump data when close if If configuration item DumpWhenClose is true
func (f *BloomFilter) Close() error {
	if f.config.DumpWhenClose {
		f.logger.Info("dump bloom filter when close")
		_ = f.Dump()
	}
	return f.BlockBloomFilter.Close()
}

// NewBloomFilter create a bloom filter based on the bloom config.
// Firstly create a directory to store the bloom filter data according chainID.
// Then create the bloom filter with some options based on the bloom config.
// The bloom filter use key calculate bit generated by contractName and key for format '{contractName}#{key}'
func NewBloomFilter(chainId string, config *conf.BloomConfig, logger protocol.Logger,
	blockLoader BlockLoader) (*BloomFilter, error) {
	if err := checkConfig(config); err != nil {
		return nil, err
	}
	dumpPath := path.Join(config.DumpPath, chainId)
	if err := createDirIfNotExist(dumpPath); err != nil {
		return nil, err
	}
	dumpPerBlocks := config.DumpPerBlocksCommitted
	//如果用户强制配置<0，忽略dump.
	if dumpPerBlocks == 0 {
		dumpPerBlocks = defaultBloomDumpPerBlocks
	}
	opts := []bloom.Option{bloom.WithLogger(logger),
		bloom.WithContractKeyGenerator(keyGenerator),
		bloom.WithDumpAsync(), bloom.WithRestoreAsync(),
		bloom.WithDumpCycle(dumpPerBlocks),
		bloom.WithDumpFile(path.Join(dumpPath, "bloom.dump")),
	}
	if blockLoader != nil {
		opts = append(opts, bloom.WithBlockLoader(&blocksLoader{
			logger:      logger,
			BlockLoader: blockLoader,
		}))
	}
	bf, err := bloom.NewBlockBloomFilter(config.KeysCapacity, config.FalsePositiveRate, opts...)
	if err != nil {
		return nil, err
	}
	return &BloomFilter{
		BlockBloomFilter: bf,
		config:           config,
		logger:           logger,
	}, nil
}

func keyGenerator(contractName string, key []byte) []byte {
	b := make([]byte, 0, len(key)+len(contractName)+1)
	return append(append(append(b, []byte(contractName)...), contractStoreSeparator), key...)
}

func checkConfig(c *conf.BloomConfig) error {
	if c == nil {
		return fmt.Errorf("bloom config is invalid")
	}
	if c.KeysCapacity <= 0 {
		return fmt.Errorf("bloom config is invalid: keysCapacity be greater than 0")
	}
	if c.FalsePositiveRate <= 0 {
		return fmt.Errorf("bloom config is invalid: falsePositiveRate be greater than 0")
	}
	return nil
}

// BlockLoader used to load blocks
// As an intermediate conversion, it coverts storeImpl to bloom.BlockLoader
type BlockLoader interface {
	GetLastHeight() (uint64, error)
	GetBlockWithRWSets(height uint64) (*storePb.BlockWithRWSet, error)
}

type blocksLoader struct {
	logger protocol.Logger
	BlockLoader
}

// Height get the last height if error occur retry.
func (l *blocksLoader) Height() uint64 {
	for {
		h, err := l.BlockLoader.GetLastHeight()
		if err == nil {
			return h
		}
		l.logger.Debugf("get last height for bloom restore block failed: %s", err)
		time.Sleep(20 * time.Millisecond)
	}
}

func createDirIfNotExist(dir string) error {
	_, err := os.Stat(dir)
	if err == nil {
		return nil
	}
	if os.IsNotExist(err) {
		err = os.MkdirAll(dir, os.ModePerm)
	}
	return err
}
