// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: consensus/consensus.proto

package consensus

import (
	common "techtradechain.com/techtradechain/pb-go/v2/common"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ConsensusType int32

const (
	ConsensusType_SOLO   ConsensusType = 0
	ConsensusType_TBFT   ConsensusType = 1
	ConsensusType_MBFT   ConsensusType = 2
	ConsensusType_MAXBFT ConsensusType = 3
	ConsensusType_RAFT   ConsensusType = 4
	ConsensusType_DPOS   ConsensusType = 5
	ConsensusType_POW    ConsensusType = 10
)

var ConsensusType_name = map[int32]string{
	0:  "SOLO",
	1:  "TBFT",
	2:  "MBFT",
	3:  "MAXBFT",
	4:  "RAFT",
	5:  "DPOS",
	10: "POW",
}

var ConsensusType_value = map[string]int32{
	"SOLO":   0,
	"TBFT":   1,
	"MBFT":   2,
	"MAXBFT": 3,
	"RAFT":   4,
	"DPOS":   5,
	"POW":    10,
}

func (x ConsensusType) String() string {
	return proto.EnumName(ConsensusType_name, int32(x))
}

func (ConsensusType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{0}
}

type VerifyResult_Code int32

const (
	VerifyResult_SUCCESS VerifyResult_Code = 0
	VerifyResult_FAIL    VerifyResult_Code = 1
)

var VerifyResult_Code_name = map[int32]string{
	0: "SUCCESS",
	1: "FAIL",
}

var VerifyResult_Code_value = map[string]int32{
	"SUCCESS": 0,
	"FAIL":    1,
}

func (x VerifyResult_Code) String() string {
	return proto.EnumName(VerifyResult_Code_name, int32(x))
}

func (VerifyResult_Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{0, 0}
}

type VerifyResult struct {
	VerifiedBlock      *common.Block              `protobuf:"bytes,1,opt,name=verified_block,json=verifiedBlock,proto3" json:"verified_block,omitempty"`
	Code               VerifyResult_Code          `protobuf:"varint,2,opt,name=code,proto3,enum=consensus.VerifyResult_Code" json:"code,omitempty"`
	Msg                string                     `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
	TxsRwSet           map[string]*common.TxRWSet `protobuf:"bytes,4,rep,name=txs_rw_set,json=txsRwSet,proto3" json:"txs_rw_set,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RwSetVerifyFailTxs *RwSetVerifyFailTxs        `protobuf:"bytes,5,opt,name=rw_set_verify_fail_txs,json=rwSetVerifyFailTxs,proto3" json:"rw_set_verify_fail_txs,omitempty"`
}

func (m *VerifyResult) Reset()         { *m = VerifyResult{} }
func (m *VerifyResult) String() string { return proto.CompactTextString(m) }
func (*VerifyResult) ProtoMessage()    {}
func (*VerifyResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{0}
}
func (m *VerifyResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyResult.Merge(m, src)
}
func (m *VerifyResult) XXX_Size() int {
	return m.Size()
}
func (m *VerifyResult) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyResult.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyResult proto.InternalMessageInfo

func (m *VerifyResult) GetVerifiedBlock() *common.Block {
	if m != nil {
		return m.VerifiedBlock
	}
	return nil
}

func (m *VerifyResult) GetCode() VerifyResult_Code {
	if m != nil {
		return m.Code
	}
	return VerifyResult_SUCCESS
}

func (m *VerifyResult) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *VerifyResult) GetTxsRwSet() map[string]*common.TxRWSet {
	if m != nil {
		return m.TxsRwSet
	}
	return nil
}

func (m *VerifyResult) GetRwSetVerifyFailTxs() *RwSetVerifyFailTxs {
	if m != nil {
		return m.RwSetVerifyFailTxs
	}
	return nil
}

type RwSetVerifyFailTxs struct {
	BlockHeight uint64   `protobuf:"varint,1,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	TxIds       []string `protobuf:"bytes,2,rep,name=tx_ids,json=txIds,proto3" json:"tx_ids,omitempty"`
}

func (m *RwSetVerifyFailTxs) Reset()         { *m = RwSetVerifyFailTxs{} }
func (m *RwSetVerifyFailTxs) String() string { return proto.CompactTextString(m) }
func (*RwSetVerifyFailTxs) ProtoMessage()    {}
func (*RwSetVerifyFailTxs) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{1}
}
func (m *RwSetVerifyFailTxs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RwSetVerifyFailTxs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RwSetVerifyFailTxs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RwSetVerifyFailTxs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RwSetVerifyFailTxs.Merge(m, src)
}
func (m *RwSetVerifyFailTxs) XXX_Size() int {
	return m.Size()
}
func (m *RwSetVerifyFailTxs) XXX_DiscardUnknown() {
	xxx_messageInfo_RwSetVerifyFailTxs.DiscardUnknown(m)
}

var xxx_messageInfo_RwSetVerifyFailTxs proto.InternalMessageInfo

func (m *RwSetVerifyFailTxs) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *RwSetVerifyFailTxs) GetTxIds() []string {
	if m != nil {
		return m.TxIds
	}
	return nil
}

type ProposalBlock struct {
	Block    *common.Block              `protobuf:"bytes,1,opt,name=block,proto3" json:"block,omitempty"`
	TxsRwSet map[string]*common.TxRWSet `protobuf:"bytes,2,rep,name=txs_rw_set,json=txsRwSet,proto3" json:"txs_rw_set,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	CutBlock *common.Block              `protobuf:"bytes,3,opt,name=cut_block,json=cutBlock,proto3" json:"cut_block,omitempty"`
}

func (m *ProposalBlock) Reset()         { *m = ProposalBlock{} }
func (m *ProposalBlock) String() string { return proto.CompactTextString(m) }
func (*ProposalBlock) ProtoMessage()    {}
func (*ProposalBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{2}
}
func (m *ProposalBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalBlock.Merge(m, src)
}
func (m *ProposalBlock) XXX_Size() int {
	return m.Size()
}
func (m *ProposalBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalBlock.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalBlock proto.InternalMessageInfo

func (m *ProposalBlock) GetBlock() *common.Block {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *ProposalBlock) GetTxsRwSet() map[string]*common.TxRWSet {
	if m != nil {
		return m.TxsRwSet
	}
	return nil
}

func (m *ProposalBlock) GetCutBlock() *common.Block {
	if m != nil {
		return m.CutBlock
	}
	return nil
}

type BlockHeaderConsensusArgs struct {
	ConsensusType int64 `protobuf:"varint,1,opt,name=consensus_type,json=consensusType,proto3" json:"consensus_type,omitempty"`
	// status of the round in tbft
	Round uint64 `protobuf:"varint,2,opt,name=round,proto3" json:"round,omitempty"`
	// status of the view in maxbft
	View          uint64          `protobuf:"varint,3,opt,name=view,proto3" json:"view,omitempty"`
	ConsensusData *common.TxRWSet `protobuf:"bytes,4,opt,name=consensus_data,json=consensusData,proto3" json:"consensus_data,omitempty"`
}

func (m *BlockHeaderConsensusArgs) Reset()         { *m = BlockHeaderConsensusArgs{} }
func (m *BlockHeaderConsensusArgs) String() string { return proto.CompactTextString(m) }
func (*BlockHeaderConsensusArgs) ProtoMessage()    {}
func (*BlockHeaderConsensusArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{3}
}
func (m *BlockHeaderConsensusArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockHeaderConsensusArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockHeaderConsensusArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockHeaderConsensusArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockHeaderConsensusArgs.Merge(m, src)
}
func (m *BlockHeaderConsensusArgs) XXX_Size() int {
	return m.Size()
}
func (m *BlockHeaderConsensusArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockHeaderConsensusArgs.DiscardUnknown(m)
}

var xxx_messageInfo_BlockHeaderConsensusArgs proto.InternalMessageInfo

func (m *BlockHeaderConsensusArgs) GetConsensusType() int64 {
	if m != nil {
		return m.ConsensusType
	}
	return 0
}

func (m *BlockHeaderConsensusArgs) GetRound() uint64 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *BlockHeaderConsensusArgs) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *BlockHeaderConsensusArgs) GetConsensusData() *common.TxRWSet {
	if m != nil {
		return m.ConsensusData
	}
	return nil
}

type GovernanceMember struct {
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Index  int64  `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
}

func (m *GovernanceMember) Reset()         { *m = GovernanceMember{} }
func (m *GovernanceMember) String() string { return proto.CompactTextString(m) }
func (*GovernanceMember) ProtoMessage()    {}
func (*GovernanceMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{4}
}
func (m *GovernanceMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GovernanceMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GovernanceMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GovernanceMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GovernanceMember.Merge(m, src)
}
func (m *GovernanceMember) XXX_Size() int {
	return m.Size()
}
func (m *GovernanceMember) XXX_DiscardUnknown() {
	xxx_messageInfo_GovernanceMember.DiscardUnknown(m)
}

var xxx_messageInfo_GovernanceMember proto.InternalMessageInfo

func (m *GovernanceMember) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *GovernanceMember) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

type GovernanceContract struct {
	EpochId           uint64        `protobuf:"varint,1,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	Type              ConsensusType `protobuf:"varint,2,opt,name=type,proto3,enum=consensus.ConsensusType" json:"type,omitempty"`
	CurMaxIndex       int64         `protobuf:"varint,3,opt,name=cur_max_index,json=curMaxIndex,proto3" json:"cur_max_index,omitempty"`
	SkipTimeoutCommit bool          `protobuf:"varint,4,opt,name=skip_timeout_commit,json=skipTimeoutCommit,proto3" json:"skip_timeout_commit,omitempty"`
	//bool is_config_chg = 4;   //is the configuration changed
	//bool is_validator_chg = 5;    //is the validator changed
	ConfigSequence                 uint64              `protobuf:"varint,6,opt,name=config_sequence,json=configSequence,proto3" json:"config_sequence,omitempty"`
	N                              uint64              `protobuf:"varint,7,opt,name=n,proto3" json:"n,omitempty"`
	MinQuorumForQc                 uint64              `protobuf:"varint,8,opt,name=min_quorum_for_qc,json=minQuorumForQc,proto3" json:"min_quorum_for_qc,omitempty"`
	CachedLen                      uint64              `protobuf:"varint,9,opt,name=cached_len,json=cachedLen,proto3" json:"cached_len,omitempty"`
	NextSwitchHeight               uint64              `protobuf:"varint,10,opt,name=next_switch_height,json=nextSwitchHeight,proto3" json:"next_switch_height,omitempty"`
	TransitBlock                   uint64              `protobuf:"varint,11,opt,name=transit_block,json=transitBlock,proto3" json:"transit_block,omitempty"`
	BlockNumPerEpoch               uint64              `protobuf:"varint,12,opt,name=block_num_per_epoch,json=blockNumPerEpoch,proto3" json:"block_num_per_epoch,omitempty"`
	ValidatorNum                   uint64              `protobuf:"varint,13,opt,name=validator_num,json=validatorNum,proto3" json:"validator_num,omitempty"`
	NodeProposeRound               uint64              `protobuf:"varint,14,opt,name=node_propose_round,json=nodeProposeRound,proto3" json:"node_propose_round,omitempty"`
	Members                        []*GovernanceMember `protobuf:"bytes,15,rep,name=members,proto3" json:"members,omitempty"`
	Validators                     []*GovernanceMember `protobuf:"bytes,16,rep,name=validators,proto3" json:"validators,omitempty"`
	NextValidators                 []*GovernanceMember `protobuf:"bytes,17,rep,name=next_validators,json=nextValidators,proto3" json:"next_validators,omitempty"`
	LastMinQuorumForQc             uint64              `protobuf:"varint,18,opt,name=last_min_quorum_for_qc,json=lastMinQuorumForQc,proto3" json:"last_min_quorum_for_qc,omitempty"`
	MaxbftRoundTimeoutMill         uint64              `protobuf:"varint,19,opt,name=maxbft_round_timeout_mill,json=maxbftRoundTimeoutMill,proto3" json:"maxbft_round_timeout_mill,omitempty"`
	MaxbftRoundTimeoutIntervalMill uint64              `protobuf:"varint,20,opt,name=maxbft_round_timeout_interval_mill,json=maxbftRoundTimeoutIntervalMill,proto3" json:"maxbft_round_timeout_interval_mill,omitempty"`
	LastValidators                 []*GovernanceMember `protobuf:"bytes,21,rep,name=last_validators,json=lastValidators,proto3" json:"last_validators,omitempty"`
}

func (m *GovernanceContract) Reset()         { *m = GovernanceContract{} }
func (m *GovernanceContract) String() string { return proto.CompactTextString(m) }
func (*GovernanceContract) ProtoMessage()    {}
func (*GovernanceContract) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{5}
}
func (m *GovernanceContract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GovernanceContract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GovernanceContract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GovernanceContract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GovernanceContract.Merge(m, src)
}
func (m *GovernanceContract) XXX_Size() int {
	return m.Size()
}
func (m *GovernanceContract) XXX_DiscardUnknown() {
	xxx_messageInfo_GovernanceContract.DiscardUnknown(m)
}

var xxx_messageInfo_GovernanceContract proto.InternalMessageInfo

func (m *GovernanceContract) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

func (m *GovernanceContract) GetType() ConsensusType {
	if m != nil {
		return m.Type
	}
	return ConsensusType_SOLO
}

func (m *GovernanceContract) GetCurMaxIndex() int64 {
	if m != nil {
		return m.CurMaxIndex
	}
	return 0
}

func (m *GovernanceContract) GetSkipTimeoutCommit() bool {
	if m != nil {
		return m.SkipTimeoutCommit
	}
	return false
}

func (m *GovernanceContract) GetConfigSequence() uint64 {
	if m != nil {
		return m.ConfigSequence
	}
	return 0
}

func (m *GovernanceContract) GetN() uint64 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *GovernanceContract) GetMinQuorumForQc() uint64 {
	if m != nil {
		return m.MinQuorumForQc
	}
	return 0
}

func (m *GovernanceContract) GetCachedLen() uint64 {
	if m != nil {
		return m.CachedLen
	}
	return 0
}

func (m *GovernanceContract) GetNextSwitchHeight() uint64 {
	if m != nil {
		return m.NextSwitchHeight
	}
	return 0
}

func (m *GovernanceContract) GetTransitBlock() uint64 {
	if m != nil {
		return m.TransitBlock
	}
	return 0
}

func (m *GovernanceContract) GetBlockNumPerEpoch() uint64 {
	if m != nil {
		return m.BlockNumPerEpoch
	}
	return 0
}

func (m *GovernanceContract) GetValidatorNum() uint64 {
	if m != nil {
		return m.ValidatorNum
	}
	return 0
}

func (m *GovernanceContract) GetNodeProposeRound() uint64 {
	if m != nil {
		return m.NodeProposeRound
	}
	return 0
}

func (m *GovernanceContract) GetMembers() []*GovernanceMember {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *GovernanceContract) GetValidators() []*GovernanceMember {
	if m != nil {
		return m.Validators
	}
	return nil
}

func (m *GovernanceContract) GetNextValidators() []*GovernanceMember {
	if m != nil {
		return m.NextValidators
	}
	return nil
}

func (m *GovernanceContract) GetLastMinQuorumForQc() uint64 {
	if m != nil {
		return m.LastMinQuorumForQc
	}
	return 0
}

func (m *GovernanceContract) GetMaxbftRoundTimeoutMill() uint64 {
	if m != nil {
		return m.MaxbftRoundTimeoutMill
	}
	return 0
}

func (m *GovernanceContract) GetMaxbftRoundTimeoutIntervalMill() uint64 {
	if m != nil {
		return m.MaxbftRoundTimeoutIntervalMill
	}
	return 0
}

func (m *GovernanceContract) GetLastValidators() []*GovernanceMember {
	if m != nil {
		return m.LastValidators
	}
	return nil
}

// rpc get consensus status by the request
type GetConsensusStatusRequest struct {
	// blockchain identifier
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *GetConsensusStatusRequest) Reset()         { *m = GetConsensusStatusRequest{} }
func (m *GetConsensusStatusRequest) String() string { return proto.CompactTextString(m) }
func (*GetConsensusStatusRequest) ProtoMessage()    {}
func (*GetConsensusStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{6}
}
func (m *GetConsensusStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetConsensusStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetConsensusStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetConsensusStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConsensusStatusRequest.Merge(m, src)
}
func (m *GetConsensusStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetConsensusStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConsensusStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetConsensusStatusRequest proto.InternalMessageInfo

func (m *GetConsensusStatusRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

type Validators struct {
	Nodes []string `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
}

func (m *Validators) Reset()         { *m = Validators{} }
func (m *Validators) String() string { return proto.CompactTextString(m) }
func (*Validators) ProtoMessage()    {}
func (*Validators) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{7}
}
func (m *Validators) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Validators) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Validators.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Validators) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Validators.Merge(m, src)
}
func (m *Validators) XXX_Size() int {
	return m.Size()
}
func (m *Validators) XXX_DiscardUnknown() {
	xxx_messageInfo_Validators.DiscardUnknown(m)
}

var xxx_messageInfo_Validators proto.InternalMessageInfo

func (m *Validators) GetNodes() []string {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func init() {
	proto.RegisterEnum("consensus.ConsensusType", ConsensusType_name, ConsensusType_value)
	proto.RegisterEnum("consensus.VerifyResult_Code", VerifyResult_Code_name, VerifyResult_Code_value)
	proto.RegisterType((*VerifyResult)(nil), "consensus.VerifyResult")
	proto.RegisterMapType((map[string]*common.TxRWSet)(nil), "consensus.VerifyResult.TxsRwSetEntry")
	proto.RegisterType((*RwSetVerifyFailTxs)(nil), "consensus.RwSetVerifyFailTxs")
	proto.RegisterType((*ProposalBlock)(nil), "consensus.ProposalBlock")
	proto.RegisterMapType((map[string]*common.TxRWSet)(nil), "consensus.ProposalBlock.TxsRwSetEntry")
	proto.RegisterType((*BlockHeaderConsensusArgs)(nil), "consensus.BlockHeaderConsensusArgs")
	proto.RegisterType((*GovernanceMember)(nil), "consensus.GovernanceMember")
	proto.RegisterType((*GovernanceContract)(nil), "consensus.GovernanceContract")
	proto.RegisterType((*GetConsensusStatusRequest)(nil), "consensus.GetConsensusStatusRequest")
	proto.RegisterType((*Validators)(nil), "consensus.Validators")
}

func init() { proto.RegisterFile("consensus/consensus.proto", fileDescriptor_477fc6492de41e15) }

var fileDescriptor_477fc6492de41e15 = []byte{
	// 1117 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcd, 0x72, 0x1b, 0x45,
	0x10, 0xf6, 0x5a, 0x2b, 0xcb, 0x6a, 0x59, 0xb2, 0x32, 0xf9, 0x61, 0x9d, 0x10, 0x95, 0x51, 0x2a,
	0x60, 0x52, 0x89, 0x4c, 0x09, 0x48, 0xf1, 0x73, 0xb2, 0xe5, 0x38, 0x88, 0xb2, 0x62, 0x67, 0x25,
	0x12, 0x8a, 0xcb, 0xd4, 0x6a, 0x77, 0x2c, 0x6d, 0x79, 0x77, 0x47, 0x99, 0x99, 0x95, 0xa5, 0x87,
	0xa0, 0x8a, 0x77, 0xe0, 0x4d, 0x38, 0x71, 0xcc, 0x91, 0x23, 0x95, 0xbc, 0x02, 0x0f, 0x40, 0x4d,
	0x8f, 0x7e, 0xd6, 0xd8, 0x21, 0x1c, 0xb8, 0x4d, 0x7f, 0xdd, 0xfd, 0xf5, 0xbf, 0x56, 0xb0, 0xe5,
	0xf3, 0x44, 0xb2, 0x44, 0xa6, 0x72, 0x77, 0xf1, 0x6a, 0x8c, 0x04, 0x57, 0x9c, 0x14, 0x17, 0xc0,
	0x6d, 0xe2, 0xf3, 0x38, 0xe6, 0xc9, 0x6e, 0x3f, 0xe2, 0xfe, 0x99, 0x51, 0x2f, 0x30, 0x71, 0x2e,
	0x99, 0x32, 0x58, 0xfd, 0xe7, 0x1c, 0x6c, 0xbc, 0x60, 0x22, 0x3c, 0x9d, 0xba, 0x4c, 0xa6, 0x91,
	0x22, 0x5f, 0x40, 0x65, 0xac, 0xe5, 0x90, 0x05, 0x14, 0x9d, 0x1d, 0x6b, 0xdb, 0xda, 0x29, 0x35,
	0xcb, 0x0d, 0xe3, 0xdd, 0xd8, 0xd7, 0xa0, 0x5b, 0x9e, 0x1b, 0xa1, 0x48, 0x3e, 0x03, 0xdb, 0xe7,
	0x01, 0x73, 0x56, 0xb7, 0xad, 0x9d, 0x4a, 0xf3, 0xc3, 0xc6, 0x32, 0xb3, 0x2c, 0x79, 0xa3, 0xc5,
	0x03, 0xe6, 0xa2, 0x25, 0xa9, 0x42, 0x2e, 0x96, 0x03, 0x27, 0xb7, 0x6d, 0xed, 0x14, 0x5d, 0xfd,
	0x24, 0x2d, 0x00, 0x35, 0x91, 0x54, 0x9c, 0x53, 0xc9, 0x94, 0x63, 0x6f, 0xe7, 0x76, 0x4a, 0xcd,
	0xfb, 0xef, 0x62, 0xea, 0x4d, 0xa4, 0x7b, 0xde, 0x65, 0xea, 0x49, 0xa2, 0xc4, 0xd4, 0x5d, 0x57,
	0x33, 0x91, 0x3c, 0x87, 0x5b, 0x86, 0x80, 0x62, 0x82, 0x53, 0x7a, 0xea, 0x85, 0x11, 0x55, 0x13,
	0xe9, 0xe4, 0xb1, 0x8c, 0xbb, 0x19, 0x42, 0xf4, 0x30, 0xac, 0x87, 0x5e, 0x18, 0x69, 0x4a, 0x22,
	0x2e, 0x61, 0xb7, 0x8f, 0xa0, 0x7c, 0x21, 0x9a, 0x4e, 0xfd, 0x8c, 0x4d, 0xb1, 0x2f, 0x45, 0x57,
	0x3f, 0xc9, 0x7d, 0xc8, 0x8f, 0xbd, 0x28, 0x35, 0xf5, 0x97, 0x9a, 0x9b, 0xf3, 0x5e, 0xf5, 0x26,
	0xee, 0xcb, 0x2e, 0x53, 0xae, 0xd1, 0x7e, 0xb3, 0xfa, 0x95, 0x55, 0xbf, 0x0b, 0xb6, 0xee, 0x02,
	0x29, 0x41, 0xa1, 0xfb, 0x43, 0xab, 0xf5, 0xa4, 0xdb, 0xad, 0xae, 0x90, 0x75, 0xb0, 0x0f, 0xf7,
	0xda, 0x47, 0x55, 0xab, 0xfe, 0x0c, 0xc8, 0xe5, 0xb4, 0xc8, 0x47, 0xb0, 0x81, 0xb3, 0xa0, 0x43,
	0x16, 0x0e, 0x86, 0x0a, 0x43, 0xdb, 0x6e, 0x09, 0xb1, 0xef, 0x10, 0x22, 0x37, 0x61, 0x4d, 0x4d,
	0x68, 0x18, 0x48, 0x67, 0x75, 0x3b, 0xb7, 0x53, 0x74, 0xf3, 0x6a, 0xd2, 0x0e, 0x64, 0xfd, 0x2f,
	0x0b, 0xca, 0x27, 0x82, 0x8f, 0xb8, 0xf4, 0x22, 0x33, 0xaa, 0x7b, 0x90, 0xff, 0x97, 0xb9, 0x1a,
	0x1d, 0x39, 0xb8, 0x30, 0x8b, 0x55, 0x9c, 0xc5, 0xc7, 0x99, 0xd6, 0x5d, 0xa0, 0x7c, 0xe7, 0x30,
	0x1e, 0x40, 0xd1, 0x4f, 0xd5, 0x6c, 0x8d, 0x72, 0x57, 0x85, 0x5b, 0xf7, 0x53, 0x85, 0xaf, 0xff,
	0xb9, 0xcb, 0xbf, 0x5a, 0xe0, 0xec, 0x9b, 0xee, 0x78, 0x01, 0x13, 0xad, 0x79, 0xe2, 0x7b, 0x62,
	0x20, 0xc9, 0x7d, 0xa8, 0x2c, 0x2a, 0xa1, 0x6a, 0x3a, 0x62, 0x18, 0x24, 0xe7, 0x96, 0x17, 0x68,
	0x6f, 0x3a, 0x62, 0xe4, 0x06, 0xe4, 0x05, 0x4f, 0x93, 0x00, 0xc3, 0xd9, 0xae, 0x11, 0x08, 0x01,
	0x7b, 0x1c, 0xb2, 0x73, 0x2c, 0xc7, 0x76, 0xf1, 0x4d, 0x1e, 0x67, 0x09, 0x03, 0x4f, 0x79, 0x8e,
	0x7d, 0x75, 0x86, 0xcb, 0x08, 0x07, 0x9e, 0xf2, 0xea, 0x7b, 0x50, 0x7d, 0xca, 0xc7, 0x4c, 0x24,
	0x5e, 0xe2, 0xb3, 0x0e, 0x8b, 0xfb, 0x4c, 0x90, 0x0f, 0xa0, 0x90, 0xf0, 0x80, 0xd1, 0x30, 0x98,
	0x95, 0xbe, 0xa6, 0xc5, 0x76, 0xa0, 0xd3, 0x09, 0x93, 0x80, 0x4d, 0x30, 0x9d, 0x9c, 0x6b, 0x84,
	0xfa, 0x6f, 0x05, 0x20, 0x4b, 0x8e, 0x16, 0x4f, 0x94, 0xf0, 0x7c, 0x45, 0xb6, 0x60, 0x9d, 0x8d,
	0xb8, 0x3f, 0x9c, 0xd3, 0xd8, 0x6e, 0x01, 0xe5, 0x76, 0x40, 0x1e, 0x82, 0x8d, 0x35, 0x9b, 0x53,
	0x75, 0x32, 0x43, 0x6d, 0x65, 0xcb, 0x77, 0xd1, 0x8a, 0xd4, 0xa1, 0xec, 0xa7, 0x82, 0xc6, 0xde,
	0x84, 0x9a, 0xe8, 0x39, 0x8c, 0x5e, 0xf2, 0x53, 0xd1, 0xf1, 0x26, 0x6d, 0x0d, 0x91, 0x06, 0x5c,
	0x97, 0x67, 0xe1, 0x88, 0xaa, 0x30, 0x66, 0x3c, 0x55, 0x54, 0x17, 0x1d, 0x2a, 0xec, 0xc1, 0xba,
	0x7b, 0x4d, 0xab, 0x7a, 0x46, 0xd3, 0x42, 0x05, 0xf9, 0x04, 0x36, 0x7d, 0x9e, 0x9c, 0x86, 0x03,
	0x2a, 0xd9, 0xab, 0x94, 0x25, 0x3e, 0x73, 0xd6, 0x30, 0xc7, 0x8a, 0x81, 0xbb, 0x33, 0x94, 0x6c,
	0x80, 0x95, 0x38, 0x05, 0x54, 0x59, 0x09, 0xf9, 0x14, 0xae, 0xc5, 0x61, 0x42, 0x5f, 0xa5, 0x5c,
	0xa4, 0x31, 0x3d, 0xe5, 0x82, 0xbe, 0xf2, 0x9d, 0x75, 0xe3, 0x18, 0x87, 0xc9, 0x73, 0xc4, 0x0f,
	0xb9, 0x78, 0xee, 0x93, 0xbb, 0x00, 0xbe, 0xe7, 0x0f, 0x59, 0x40, 0x23, 0x96, 0x38, 0x45, 0xb4,
	0x29, 0x1a, 0xe4, 0x88, 0x25, 0xe4, 0x21, 0x90, 0x84, 0x4d, 0x14, 0x95, 0xe7, 0xa1, 0xf2, 0x87,
	0xf3, 0xa3, 0x02, 0x34, 0xab, 0x6a, 0x4d, 0x17, 0x15, 0xb3, 0xcb, 0xba, 0x07, 0x65, 0x25, 0xbc,
	0x44, 0x86, 0xf3, 0x4d, 0x2e, 0xa1, 0xe1, 0xc6, 0x0c, 0x34, 0x57, 0xf5, 0x08, 0xae, 0x9b, 0x0b,
	0x4d, 0xd2, 0x98, 0x8e, 0x98, 0xa0, 0xd8, 0x6e, 0x67, 0xc3, 0x70, 0xa2, 0xea, 0x59, 0x1a, 0x9f,
	0x30, 0xf1, 0x44, 0xe3, 0x9a, 0x73, 0xec, 0x45, 0x61, 0xe0, 0x29, 0x2e, 0xb4, 0x8b, 0x53, 0x36,
	0x9c, 0x0b, 0xf0, 0x59, 0x1a, 0x63, 0x9a, 0x7a, 0x15, 0x46, 0x78, 0x6c, 0x8c, 0x9a, 0x6d, 0xac,
	0xcc, 0xd2, 0xe4, 0x01, 0x33, 0x57, 0xc8, 0x5c, 0x5c, 0xcc, 0x2f, 0xa1, 0x10, 0xe3, 0x0a, 0x49,
	0x67, 0x13, 0xef, 0xf5, 0x4e, 0x66, 0xb4, 0xff, 0x5c, 0x33, 0x77, 0x6e, 0x4b, 0xbe, 0x05, 0x58,
	0x04, 0x95, 0x4e, 0xf5, 0xfd, 0x9e, 0x19, 0x73, 0x72, 0x00, 0x9b, 0xd8, 0xc8, 0x0c, 0xc3, 0xb5,
	0xf7, 0x33, 0x54, 0xb4, 0xcf, 0x8b, 0x25, 0x4b, 0x13, 0x6e, 0x45, 0x9e, 0x54, 0xf4, 0xf2, 0x74,
	0x09, 0xd6, 0x4a, 0xb4, 0xb6, 0x73, 0x71, 0xc2, 0x5f, 0xc3, 0x56, 0xec, 0x4d, 0xfa, 0xa7, 0xca,
	0x74, 0x65, 0xb1, 0x7b, 0x71, 0x18, 0x45, 0xce, 0x75, 0x74, 0xbb, 0x65, 0x0c, 0xb0, 0x3b, 0xb3,
	0x05, 0xec, 0x84, 0x51, 0x44, 0xbe, 0x87, 0xfa, 0x95, 0xae, 0x61, 0xa2, 0x98, 0x18, 0x7b, 0x91,
	0xe1, 0xb8, 0x81, 0x1c, 0xb5, 0xcb, 0x1c, 0xed, 0x99, 0x19, 0x72, 0x1d, 0xc0, 0x26, 0xa6, 0x9e,
	0x69, 0xc0, 0xcd, 0xff, 0xd0, 0x00, 0xed, 0xb3, 0x6c, 0x40, 0xfd, 0x31, 0x6c, 0x3d, 0x65, 0x6a,
	0x71, 0x7e, 0x5d, 0xe5, 0xa9, 0x54, 0xba, 0xfa, 0x0a, 0x24, 0x9e, 0xb2, 0x3f, 0xf4, 0xc2, 0x64,
	0xf9, 0x8b, 0x50, 0x40, 0xb9, 0x1d, 0xd4, 0xeb, 0x00, 0x99, 0x36, 0xde, 0x80, 0xbc, 0x5e, 0x0a,
	0xe9, 0x58, 0xe6, 0x03, 0x80, 0xc2, 0x83, 0x17, 0x50, 0xbe, 0x70, 0xd7, 0xfa, 0x5b, 0xd3, 0x3d,
	0x3e, 0x3a, 0x36, 0x5f, 0x9d, 0xde, 0xfe, 0x61, 0xaf, 0x6a, 0xe9, 0x57, 0x47, 0xbf, 0x56, 0x09,
	0xc0, 0x5a, 0x67, 0xef, 0x47, 0xfd, 0xce, 0x69, 0xd4, 0xdd, 0x3b, 0xec, 0x55, 0x6d, 0xfd, 0x3a,
	0x38, 0x39, 0xee, 0x56, 0xf3, 0xa4, 0x00, 0xb9, 0x93, 0xe3, 0x97, 0x55, 0xd8, 0xf7, 0x7f, 0x7f,
	0x53, 0xb3, 0x5e, 0xbf, 0xa9, 0x59, 0x7f, 0xbe, 0xa9, 0x59, 0xbf, 0xbc, 0xad, 0xad, 0xbc, 0x7e,
	0x5b, 0x5b, 0xf9, 0xe3, 0x6d, 0x6d, 0x05, 0xee, 0x70, 0x31, 0x68, 0x60, 0x8a, 0xb1, 0x77, 0xc6,
	0x44, 0x63, 0xd4, 0x5f, 0xf6, 0xe2, 0xa7, 0x87, 0x19, 0x05, 0x17, 0x83, 0xdd, 0xa5, 0xb8, 0x3b,
	0xea, 0x3f, 0x1a, 0xf0, 0xdd, 0x71, 0x73, 0xf9, 0xb7, 0xa6, 0xbf, 0x86, 0x7f, 0x52, 0x3e, 0xff,
	0x3b, 0x00, 0x00, 0xff, 0xff, 0x87, 0x5d, 0xb5, 0xa4, 0xf4, 0x08, 0x00, 0x00,
}

func (m *VerifyResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RwSetVerifyFailTxs != nil {
		{
			size, err := m.RwSetVerifyFailTxs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TxsRwSet) > 0 {
		for k := range m.TxsRwSet {
			v := m.TxsRwSet[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintConsensus(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintConsensus(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintConsensus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.VerifiedBlock != nil {
		{
			size, err := m.VerifiedBlock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RwSetVerifyFailTxs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RwSetVerifyFailTxs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RwSetVerifyFailTxs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxIds) > 0 {
		for iNdEx := len(m.TxIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TxIds[iNdEx])
			copy(dAtA[i:], m.TxIds[iNdEx])
			i = encodeVarintConsensus(dAtA, i, uint64(len(m.TxIds[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BlockHeight != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProposalBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CutBlock != nil {
		{
			size, err := m.CutBlock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TxsRwSet) > 0 {
		for k := range m.TxsRwSet {
			v := m.TxsRwSet[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintConsensus(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintConsensus(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintConsensus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockHeaderConsensusArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockHeaderConsensusArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockHeaderConsensusArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConsensusData != nil {
		{
			size, err := m.ConsensusData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.View != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x18
	}
	if m.Round != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x10
	}
	if m.ConsensusType != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.ConsensusType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GovernanceMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GovernanceMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GovernanceMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GovernanceContract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GovernanceContract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GovernanceContract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LastValidators) > 0 {
		for iNdEx := len(m.LastValidators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LastValidators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintConsensus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.MaxbftRoundTimeoutIntervalMill != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.MaxbftRoundTimeoutIntervalMill))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.MaxbftRoundTimeoutMill != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.MaxbftRoundTimeoutMill))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.LastMinQuorumForQc != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.LastMinQuorumForQc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.NextValidators) > 0 {
		for iNdEx := len(m.NextValidators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NextValidators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintConsensus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.Validators) > 0 {
		for iNdEx := len(m.Validators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Validators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintConsensus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintConsensus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.NodeProposeRound != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.NodeProposeRound))
		i--
		dAtA[i] = 0x70
	}
	if m.ValidatorNum != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.ValidatorNum))
		i--
		dAtA[i] = 0x68
	}
	if m.BlockNumPerEpoch != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.BlockNumPerEpoch))
		i--
		dAtA[i] = 0x60
	}
	if m.TransitBlock != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.TransitBlock))
		i--
		dAtA[i] = 0x58
	}
	if m.NextSwitchHeight != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.NextSwitchHeight))
		i--
		dAtA[i] = 0x50
	}
	if m.CachedLen != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.CachedLen))
		i--
		dAtA[i] = 0x48
	}
	if m.MinQuorumForQc != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.MinQuorumForQc))
		i--
		dAtA[i] = 0x40
	}
	if m.N != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.N))
		i--
		dAtA[i] = 0x38
	}
	if m.ConfigSequence != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.ConfigSequence))
		i--
		dAtA[i] = 0x30
	}
	if m.SkipTimeoutCommit {
		i--
		if m.SkipTimeoutCommit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.CurMaxIndex != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.CurMaxIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.EpochId != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetConsensusStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetConsensusStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetConsensusStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Validators) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Validators) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Validators) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Nodes[iNdEx])
			copy(dAtA[i:], m.Nodes[iNdEx])
			i = encodeVarintConsensus(dAtA, i, uint64(len(m.Nodes[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintConsensus(dAtA []byte, offset int, v uint64) int {
	offset -= sovConsensus(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *VerifyResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VerifiedBlock != nil {
		l = m.VerifiedBlock.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovConsensus(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	if len(m.TxsRwSet) > 0 {
		for k, v := range m.TxsRwSet {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovConsensus(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovConsensus(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovConsensus(uint64(mapEntrySize))
		}
	}
	if m.RwSetVerifyFailTxs != nil {
		l = m.RwSetVerifyFailTxs.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}

func (m *RwSetVerifyFailTxs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockHeight != 0 {
		n += 1 + sovConsensus(uint64(m.BlockHeight))
	}
	if len(m.TxIds) > 0 {
		for _, s := range m.TxIds {
			l = len(s)
			n += 1 + l + sovConsensus(uint64(l))
		}
	}
	return n
}

func (m *ProposalBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	if len(m.TxsRwSet) > 0 {
		for k, v := range m.TxsRwSet {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovConsensus(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovConsensus(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovConsensus(uint64(mapEntrySize))
		}
	}
	if m.CutBlock != nil {
		l = m.CutBlock.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}

func (m *BlockHeaderConsensusArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsensusType != 0 {
		n += 1 + sovConsensus(uint64(m.ConsensusType))
	}
	if m.Round != 0 {
		n += 1 + sovConsensus(uint64(m.Round))
	}
	if m.View != 0 {
		n += 1 + sovConsensus(uint64(m.View))
	}
	if m.ConsensusData != nil {
		l = m.ConsensusData.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}

func (m *GovernanceMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovConsensus(uint64(m.Index))
	}
	return n
}

func (m *GovernanceContract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochId != 0 {
		n += 1 + sovConsensus(uint64(m.EpochId))
	}
	if m.Type != 0 {
		n += 1 + sovConsensus(uint64(m.Type))
	}
	if m.CurMaxIndex != 0 {
		n += 1 + sovConsensus(uint64(m.CurMaxIndex))
	}
	if m.SkipTimeoutCommit {
		n += 2
	}
	if m.ConfigSequence != 0 {
		n += 1 + sovConsensus(uint64(m.ConfigSequence))
	}
	if m.N != 0 {
		n += 1 + sovConsensus(uint64(m.N))
	}
	if m.MinQuorumForQc != 0 {
		n += 1 + sovConsensus(uint64(m.MinQuorumForQc))
	}
	if m.CachedLen != 0 {
		n += 1 + sovConsensus(uint64(m.CachedLen))
	}
	if m.NextSwitchHeight != 0 {
		n += 1 + sovConsensus(uint64(m.NextSwitchHeight))
	}
	if m.TransitBlock != 0 {
		n += 1 + sovConsensus(uint64(m.TransitBlock))
	}
	if m.BlockNumPerEpoch != 0 {
		n += 1 + sovConsensus(uint64(m.BlockNumPerEpoch))
	}
	if m.ValidatorNum != 0 {
		n += 1 + sovConsensus(uint64(m.ValidatorNum))
	}
	if m.NodeProposeRound != 0 {
		n += 1 + sovConsensus(uint64(m.NodeProposeRound))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovConsensus(uint64(l))
		}
	}
	if len(m.Validators) > 0 {
		for _, e := range m.Validators {
			l = e.Size()
			n += 2 + l + sovConsensus(uint64(l))
		}
	}
	if len(m.NextValidators) > 0 {
		for _, e := range m.NextValidators {
			l = e.Size()
			n += 2 + l + sovConsensus(uint64(l))
		}
	}
	if m.LastMinQuorumForQc != 0 {
		n += 2 + sovConsensus(uint64(m.LastMinQuorumForQc))
	}
	if m.MaxbftRoundTimeoutMill != 0 {
		n += 2 + sovConsensus(uint64(m.MaxbftRoundTimeoutMill))
	}
	if m.MaxbftRoundTimeoutIntervalMill != 0 {
		n += 2 + sovConsensus(uint64(m.MaxbftRoundTimeoutIntervalMill))
	}
	if len(m.LastValidators) > 0 {
		for _, e := range m.LastValidators {
			l = e.Size()
			n += 2 + l + sovConsensus(uint64(l))
		}
	}
	return n
}

func (m *GetConsensusStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}

func (m *Validators) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, s := range m.Nodes {
			l = len(s)
			n += 1 + l + sovConsensus(uint64(l))
		}
	}
	return n
}

func sovConsensus(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozConsensus(x uint64) (n int) {
	return sovConsensus(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *VerifyResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifiedBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VerifiedBlock == nil {
				m.VerifiedBlock = &common.Block{}
			}
			if err := m.VerifiedBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= VerifyResult_Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxsRwSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxsRwSet == nil {
				m.TxsRwSet = make(map[string]*common.TxRWSet)
			}
			var mapkey string
			var mapvalue *common.TxRWSet
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConsensus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConsensus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConsensus
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthConsensus
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConsensus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthConsensus
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthConsensus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &common.TxRWSet{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConsensus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthConsensus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TxsRwSet[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RwSetVerifyFailTxs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RwSetVerifyFailTxs == nil {
				m.RwSetVerifyFailTxs = &RwSetVerifyFailTxs{}
			}
			if err := m.RwSetVerifyFailTxs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RwSetVerifyFailTxs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RwSetVerifyFailTxs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RwSetVerifyFailTxs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxIds = append(m.TxIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &common.Block{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxsRwSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxsRwSet == nil {
				m.TxsRwSet = make(map[string]*common.TxRWSet)
			}
			var mapkey string
			var mapvalue *common.TxRWSet
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConsensus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConsensus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConsensus
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthConsensus
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConsensus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthConsensus
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthConsensus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &common.TxRWSet{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConsensus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthConsensus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TxsRwSet[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CutBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CutBlock == nil {
				m.CutBlock = &common.Block{}
			}
			if err := m.CutBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockHeaderConsensusArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockHeaderConsensusArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockHeaderConsensusArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusType", wireType)
			}
			m.ConsensusType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsensusType |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConsensusData == nil {
				m.ConsensusData = &common.TxRWSet{}
			}
			if err := m.ConsensusData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GovernanceMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GovernanceMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GovernanceMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GovernanceContract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GovernanceContract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GovernanceContract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ConsensusType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurMaxIndex", wireType)
			}
			m.CurMaxIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurMaxIndex |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipTimeoutCommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipTimeoutCommit = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigSequence", wireType)
			}
			m.ConfigSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigSequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuorumForQc", wireType)
			}
			m.MinQuorumForQc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinQuorumForQc |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedLen", wireType)
			}
			m.CachedLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CachedLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSwitchHeight", wireType)
			}
			m.NextSwitchHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextSwitchHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransitBlock", wireType)
			}
			m.TransitBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransitBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumPerEpoch", wireType)
			}
			m.BlockNumPerEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumPerEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorNum", wireType)
			}
			m.ValidatorNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidatorNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeProposeRound", wireType)
			}
			m.NodeProposeRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeProposeRound |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &GovernanceMember{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, &GovernanceMember{})
			if err := m.Validators[len(m.Validators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextValidators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextValidators = append(m.NextValidators, &GovernanceMember{})
			if err := m.NextValidators[len(m.NextValidators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMinQuorumForQc", wireType)
			}
			m.LastMinQuorumForQc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastMinQuorumForQc |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxbftRoundTimeoutMill", wireType)
			}
			m.MaxbftRoundTimeoutMill = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxbftRoundTimeoutMill |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxbftRoundTimeoutIntervalMill", wireType)
			}
			m.MaxbftRoundTimeoutIntervalMill = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxbftRoundTimeoutIntervalMill |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastValidators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastValidators = append(m.LastValidators, &GovernanceMember{})
			if err := m.LastValidators[len(m.LastValidators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetConsensusStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetConsensusStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetConsensusStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Validators) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Validators: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Validators: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipConsensus(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthConsensus
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupConsensus
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthConsensus
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthConsensus        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowConsensus          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupConsensus = fmt.Errorf("proto: unexpected end of group")
)
