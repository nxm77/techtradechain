// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/rpc_node.proto

package api

import (
	common "techtradechain.com/techtradechain/pb-go/v2/common"
	config "techtradechain.com/techtradechain/pb-go/v2/config"
	consensus "techtradechain.com/techtradechain/pb-go/v2/consensus"
	sync "techtradechain.com/techtradechain/pb-go/v2/sync"
	txpool "techtradechain.com/techtradechain/pb-go/v2/txpool"
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("api/rpc_node.proto", fileDescriptor_ba278e4b8f6bb771) }

var fileDescriptor_ba278e4b8f6bb771 = []byte{
	// 736 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x95, 0xcf, 0x6e, 0xd3, 0x4a,
	0x14, 0xc6, 0x9d, 0x7b, 0xa5, 0x7b, 0x75, 0xa7, 0xb7, 0x84, 0x4e, 0x93, 0xfe, 0x49, 0x8b, 0x05,
	0x06, 0x0a, 0x42, 0xc2, 0x2e, 0x05, 0xb1, 0x00, 0x36, 0xa4, 0xa0, 0x50, 0x54, 0xd2, 0x2a, 0x49,
	0x5b, 0x54, 0x21, 0x85, 0x89, 0x7d, 0xea, 0x58, 0x75, 0x67, 0x8c, 0x67, 0x9c, 0x26, 0x5b, 0x9e,
	0x00, 0x89, 0x67, 0xe1, 0x1d, 0x58, 0x56, 0x62, 0xc3, 0x12, 0xb5, 0x3c, 0x08, 0xf2, 0xd8, 0xe3,
	0x38, 0x6d, 0xd4, 0x66, 0x53, 0xd5, 0xdf, 0xf7, 0xcd, 0x6f, 0xce, 0x1c, 0x4f, 0x8e, 0x11, 0x26,
	0x81, 0x67, 0x85, 0x81, 0xdd, 0xa6, 0xcc, 0x01, 0x33, 0x08, 0x99, 0x60, 0xf8, 0x6f, 0x12, 0x78,
	0x95, 0x92, 0xcd, 0x8e, 0x8e, 0x18, 0xb5, 0x42, 0xf8, 0x14, 0x01, 0x17, 0x89, 0x55, 0x99, 0xcd,
	0x54, 0x1e, 0xf9, 0x4a, 0x5c, 0xb4, 0x19, 0x3d, 0xf0, 0x5c, 0xcb, 0x67, 0x36, 0xf1, 0xdb, 0xc9,
	0x43, 0x6a, 0xcd, 0x67, 0x96, 0x3b, 0x6a, 0xe8, 0xa9, 0x61, 0x77, 0x89, 0x47, 0x8f, 0xc8, 0x21,
	0x84, 0x6d, 0x0e, 0x61, 0x0f, 0xc2, 0xd4, 0x5f, 0x76, 0x19, 0x73, 0x7d, 0xb0, 0xe2, 0xf2, 0x08,
	0xa5, 0x4c, 0x10, 0xe1, 0x31, 0xca, 0x53, 0xf7, 0x86, 0xe8, 0x07, 0x8c, 0xf9, 0x96, 0x08, 0x09,
	0xe5, 0xc4, 0x8e, 0xad, 0x76, 0x2c, 0x28, 0x78, 0xba, 0x58, 0x3e, 0x75, 0xa2, 0x03, 0xeb, 0x38,
	0x24, 0x41, 0x00, 0x21, 0xcf, 0x15, 0xcc, 0x81, 0xf2, 0x88, 0x5b, 0xd9, 0x7f, 0xa9, 0x55, 0xe4,
	0x03, 0x6a, 0x5b, 0xf1, 0x9f, 0x44, 0x58, 0xfb, 0x86, 0xd0, 0xbf, 0x8d, 0xc0, 0xae, 0x33, 0x07,
	0xf0, 0x36, 0x9a, 0x6a, 0x02, 0x75, 0x1a, 0x49, 0x4b, 0xf0, 0x8c, 0x99, 0x74, 0xc3, 0x6c, 0xf5,
	0x53, 0xa9, 0x82, 0xf3, 0x12, 0x0f, 0x62, 0xb8, 0x51, 0xf9, 0xfc, 0xe3, 0xf7, 0xd7, 0xbf, 0x4a,
	0x46, 0xd1, 0xea, 0x3d, 0xb2, 0x38, 0x50, 0x27, 0x6d, 0xe9, 0xb3, 0xc2, 0x03, 0xfc, 0x1e, 0x15,
	0x73, 0xc4, 0xe6, 0x80, 0xda, 0x93, 0x52, 0x75, 0x49, 0x5d, 0x30, 0x66, 0xcf, 0x51, 0xe3, 0xd2,
	0x63, 0xf2, 0x73, 0xf4, 0x5f, 0x33, 0xea, 0x70, 0x3b, 0xf4, 0x3a, 0x30, 0x8e, 0x39, 0xaf, 0xa4,
	0x2c, 0xd5, 0x90, 0xef, 0xd4, 0xd0, 0x56, 0x0b, 0x78, 0x07, 0x4d, 0x65, 0xf2, 0x5e, 0x13, 0x97,
	0x54, 0xb6, 0x41, 0x8e, 0x27, 0x20, 0x94, 0x65, 0x69, 0x45, 0x3c, 0x2d, 0x4b, 0x53, 0xe6, 0x6a,
	0x01, 0xd7, 0xd1, 0xcc, 0x4e, 0xe0, 0x10, 0x01, 0xaf, 0xa0, 0x13, 0xb9, 0xeb, 0xf2, 0x06, 0xe0,
	0x8a, 0x99, 0x5e, 0x8c, 0x9c, 0xa8, 0xb6, 0x58, 0x1a, 0xeb, 0xa5, 0x1d, 0xd0, 0xf0, 0x16, 0x9a,
	0x6b, 0xc0, 0x41, 0x08, 0xbc, 0xbb, 0xc9, 0xdc, 0x4d, 0xe8, 0x81, 0xcf, 0x53, 0xe8, 0x82, 0x5a,
	0x98, 0x19, 0x0a, 0xb9, 0x38, 0xc6, 0xc9, 0x80, 0x1c, 0x95, 0x6a, 0x20, 0xd6, 0xe3, 0x3b, 0xf9,
	0x2e, 0xbe, 0x93, 0xbb, 0x10, 0x72, 0x8f, 0x51, 0x7c, 0x53, 0x2d, 0xba, 0x60, 0x29, 0xec, 0xad,
	0x4b, 0x12, 0x29, 0x7e, 0x4e, 0xb6, 0xe5, 0x3a, 0xbe, 0x16, 0xb7, 0xc5, 0x05, 0xd1, 0x4b, 0xe1,
	0x0c, 0x2d, 0xac, 0x77, 0xc1, 0x3e, 0xac, 0xc3, 0x71, 0xd5, 0x67, 0xf6, 0xa1, 0x24, 0xa4, 0xe7,
	0xb8, 0x37, 0xc4, 0x8e, 0x4f, 0xa8, 0xfd, 0xef, 0x5f, 0x1d, 0xcc, 0x4e, 0xf9, 0x1a, 0x4d, 0xd7,
	0x40, 0x6c, 0x33, 0xe6, 0x37, 0x05, 0x11, 0x11, 0xc7, 0xcb, 0x66, 0xf2, 0x7b, 0x32, 0x47, 0x64,
	0x85, 0x2e, 0x29, 0xb7, 0xd5, 0x1f, 0x9a, 0x86, 0x86, 0x3d, 0x34, 0x57, 0x03, 0xd1, 0xea, 0x6f,
	0x38, 0xbc, 0x3a, 0x68, 0x0d, 0x02, 0x78, 0x49, 0x9d, 0xa6, 0x20, 0x2e, 0xe0, 0xbb, 0x39, 0xde,
	0x18, 0x5f, 0x81, 0x57, 0xae, 0x8a, 0x65, 0x15, 0x7f, 0x44, 0xb3, 0x32, 0xc3, 0x37, 0x68, 0x5c,
	0x42, 0x75, 0x20, 0xe3, 0xd8, 0x18, 0x01, 0x8c, 0x9a, 0x6a, 0x93, 0xdb, 0x97, 0x66, 0xb2, 0x1d,
	0x3e, 0xa0, 0x72, 0xfc, 0xe6, 0xd5, 0x34, 0x88, 0x0f, 0x09, 0x6f, 0x9b, 0x5b, 0x75, 0x7c, 0xc7,
	0x1c, 0x8e, 0x88, 0xf3, 0x89, 0x61, 0x8f, 0x96, 0xcc, 0x64, 0xe4, 0x98, 0x6a, 0xe4, 0x98, 0xd5,
	0x81, 0x00, 0xbe, 0x4b, 0xfc, 0x28, 0xa6, 0xef, 0xc9, 0x56, 0x65, 0x6b, 0x77, 0x89, 0xef, 0x39,
	0x44, 0xb0, 0x90, 0x4f, 0x88, 0x2f, 0xe7, 0x52, 0xc3, 0xc5, 0x86, 0x86, 0xf7, 0x11, 0xce, 0xaf,
	0x7a, 0x03, 0x9e, 0xdb, 0x15, 0x13, 0x42, 0x97, 0x2f, 0xd4, 0xbc, 0xb3, 0x41, 0xc5, 0xd3, 0x27,
	0xaa, 0xe8, 0x17, 0xe8, 0xff, 0x1a, 0xc8, 0x99, 0x24, 0xbb, 0x81, 0x17, 0x4d, 0x39, 0x16, 0xf3,
	0x9a, 0x42, 0x15, 0x13, 0x2b, 0xd3, 0x0d, 0xad, 0xba, 0xf7, 0xfd, 0x54, 0x2f, 0x9c, 0x9c, 0xea,
	0x85, 0x5f, 0xa7, 0x7a, 0xe1, 0xcb, 0x99, 0xae, 0x9d, 0x9c, 0xe9, 0xda, 0xcf, 0x33, 0x5d, 0x43,
	0x65, 0x16, 0xba, 0xe6, 0x70, 0xee, 0x9b, 0x41, 0xc7, 0x24, 0x81, 0xb7, 0xbf, 0x92, 0x93, 0x58,
	0x98, 0xff, 0x32, 0x58, 0x41, 0xe7, 0xa1, 0xcb, 0xac, 0xde, 0x5a, 0xfc, 0x35, 0xe8, 0xfc, 0x23,
	0xcb, 0x7d, 0xfc, 0x27, 0x00, 0x00, 0xff, 0xff, 0x61, 0xfe, 0x85, 0xcd, 0xba, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RpcNodeClient is the client API for RpcNode service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RpcNodeClient interface {
	// processing transaction message requests
	SendRequest(ctx context.Context, in *common.TxRequest, opts ...grpc.CallOption) (*common.TxResponse, error)
	// processing transaction message requests in sync mode.
	// returns tx execution result
	SendRequestSync(ctx context.Context, in *common.TxRequest, opts ...grpc.CallOption) (*common.TxResponse, error)
	// processing requests for message subscription
	Subscribe(ctx context.Context, in *common.TxRequest, opts ...grpc.CallOption) (RpcNode_SubscribeClient, error)
	// processing requests for message subscription by websocket
	SubscribeWS(ctx context.Context, in *common.RawTxRequest, opts ...grpc.CallOption) (RpcNode_SubscribeWSClient, error)
	// update debug status (development debugging)
	UpdateDebugConfig(ctx context.Context, in *config.DebugConfigRequest, opts ...grpc.CallOption) (*config.DebugConfigResponse, error)
	// refreshLogLevelsConfig
	RefreshLogLevelsConfig(ctx context.Context, in *config.LogLevelsRequest, opts ...grpc.CallOption) (*config.LogLevelsResponse, error)
	// get techtradechain version
	GetTechTradeChainVersion(ctx context.Context, in *config.TechTradeChainVersionRequest, opts ...grpc.CallOption) (*config.TechTradeChainVersionResponse, error)
	// check chain configuration and load new chain dynamically
	CheckNewBlockChainConfig(ctx context.Context, in *config.CheckNewBlockChainConfigRequest, opts ...grpc.CallOption) (*config.CheckNewBlockChainConfigResponse, error)
	// GetPoolStatus Returns the max size of config transaction pool and common transaction pool,
	// the num of config transaction in queue and pendingCache,
	// and the the num of common transaction in queue and pendingCache.
	GetPoolStatus(ctx context.Context, in *txpool.GetPoolStatusRequest, opts ...grpc.CallOption) (*txpool.TxPoolStatus, error)
	// GetTxIdsByTypeAndStage Returns config or common txIds in different stage.
	// TxType may be TxType_CONFIG_TX, TxType_COMMON_TX, (TxType_CONFIG_TX|TxType_COMMON_TX)
	// TxStage may be TxStage_IN_QUEUE, TxStage_IN_PENDING, (TxStage_IN_QUEUE|TxStage_IN_PENDING)
	GetTxIdsByTypeAndStage(ctx context.Context, in *txpool.GetTxIdsByTypeAndStageRequest, opts ...grpc.CallOption) (*txpool.GetTxIdsByTypeAndStageResponse, error)
	// GetTxsInPoolByTxIds Retrieve the transactions by the txIds from the txPool,
	// return transactions in the txPool and txIds not in txPool.
	// default query upper limit is 1w transaction, and error is returned if the limit is exceeded.
	GetTxsInPoolByTxIds(ctx context.Context, in *txpool.GetTxsInPoolByTxIdsRequest, opts ...grpc.CallOption) (*txpool.GetTxsInPoolByTxIdsResponse, error)
	// GetConsensusStateJSON query the state of the consensus,
	// return the consensus status after JSON serialization, including consensus nodes, heights, and views.
	GetConsensusStateJSON(ctx context.Context, in *consensus.GetConsensusStatusRequest, opts ...grpc.CallOption) (*wrapperspb.BytesValue, error)
	// GetConsensusValidators Gets the consensus node list
	GetConsensusValidators(ctx context.Context, in *consensus.GetConsensusStatusRequest, opts ...grpc.CallOption) (*consensus.Validators, error)
	// GetConsensusHeight Gets the height of the block that the node is currently agreeing on
	GetConsensusHeight(ctx context.Context, in *consensus.GetConsensusStatusRequest, opts ...grpc.CallOption) (*wrapperspb.UInt64Value, error)
	// GetSyncState get state of sync module
	GetSyncState(ctx context.Context, in *sync.GetSyncStateRequest, opts ...grpc.CallOption) (*sync.SyncState, error)
}

type rpcNodeClient struct {
	cc *grpc.ClientConn
}

func NewRpcNodeClient(cc *grpc.ClientConn) RpcNodeClient {
	return &rpcNodeClient{cc}
}

func (c *rpcNodeClient) SendRequest(ctx context.Context, in *common.TxRequest, opts ...grpc.CallOption) (*common.TxResponse, error) {
	out := new(common.TxResponse)
	err := c.cc.Invoke(ctx, "/api.RpcNode/SendRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcNodeClient) SendRequestSync(ctx context.Context, in *common.TxRequest, opts ...grpc.CallOption) (*common.TxResponse, error) {
	out := new(common.TxResponse)
	err := c.cc.Invoke(ctx, "/api.RpcNode/SendRequestSync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcNodeClient) Subscribe(ctx context.Context, in *common.TxRequest, opts ...grpc.CallOption) (RpcNode_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RpcNode_serviceDesc.Streams[0], "/api.RpcNode/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &rpcNodeSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RpcNode_SubscribeClient interface {
	Recv() (*common.SubscribeResult, error)
	grpc.ClientStream
}

type rpcNodeSubscribeClient struct {
	grpc.ClientStream
}

func (x *rpcNodeSubscribeClient) Recv() (*common.SubscribeResult, error) {
	m := new(common.SubscribeResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rpcNodeClient) SubscribeWS(ctx context.Context, in *common.RawTxRequest, opts ...grpc.CallOption) (RpcNode_SubscribeWSClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RpcNode_serviceDesc.Streams[1], "/api.RpcNode/SubscribeWS", opts...)
	if err != nil {
		return nil, err
	}
	x := &rpcNodeSubscribeWSClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RpcNode_SubscribeWSClient interface {
	Recv() (*common.SubscribeResult, error)
	grpc.ClientStream
}

type rpcNodeSubscribeWSClient struct {
	grpc.ClientStream
}

func (x *rpcNodeSubscribeWSClient) Recv() (*common.SubscribeResult, error) {
	m := new(common.SubscribeResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rpcNodeClient) UpdateDebugConfig(ctx context.Context, in *config.DebugConfigRequest, opts ...grpc.CallOption) (*config.DebugConfigResponse, error) {
	out := new(config.DebugConfigResponse)
	err := c.cc.Invoke(ctx, "/api.RpcNode/UpdateDebugConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcNodeClient) RefreshLogLevelsConfig(ctx context.Context, in *config.LogLevelsRequest, opts ...grpc.CallOption) (*config.LogLevelsResponse, error) {
	out := new(config.LogLevelsResponse)
	err := c.cc.Invoke(ctx, "/api.RpcNode/RefreshLogLevelsConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcNodeClient) GetTechTradeChainVersion(ctx context.Context, in *config.TechTradeChainVersionRequest, opts ...grpc.CallOption) (*config.TechTradeChainVersionResponse, error) {
	out := new(config.TechTradeChainVersionResponse)
	err := c.cc.Invoke(ctx, "/api.RpcNode/GetTechTradeChainVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcNodeClient) CheckNewBlockChainConfig(ctx context.Context, in *config.CheckNewBlockChainConfigRequest, opts ...grpc.CallOption) (*config.CheckNewBlockChainConfigResponse, error) {
	out := new(config.CheckNewBlockChainConfigResponse)
	err := c.cc.Invoke(ctx, "/api.RpcNode/CheckNewBlockChainConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcNodeClient) GetPoolStatus(ctx context.Context, in *txpool.GetPoolStatusRequest, opts ...grpc.CallOption) (*txpool.TxPoolStatus, error) {
	out := new(txpool.TxPoolStatus)
	err := c.cc.Invoke(ctx, "/api.RpcNode/GetPoolStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcNodeClient) GetTxIdsByTypeAndStage(ctx context.Context, in *txpool.GetTxIdsByTypeAndStageRequest, opts ...grpc.CallOption) (*txpool.GetTxIdsByTypeAndStageResponse, error) {
	out := new(txpool.GetTxIdsByTypeAndStageResponse)
	err := c.cc.Invoke(ctx, "/api.RpcNode/GetTxIdsByTypeAndStage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcNodeClient) GetTxsInPoolByTxIds(ctx context.Context, in *txpool.GetTxsInPoolByTxIdsRequest, opts ...grpc.CallOption) (*txpool.GetTxsInPoolByTxIdsResponse, error) {
	out := new(txpool.GetTxsInPoolByTxIdsResponse)
	err := c.cc.Invoke(ctx, "/api.RpcNode/GetTxsInPoolByTxIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcNodeClient) GetConsensusStateJSON(ctx context.Context, in *consensus.GetConsensusStatusRequest, opts ...grpc.CallOption) (*wrapperspb.BytesValue, error) {
	out := new(wrapperspb.BytesValue)
	err := c.cc.Invoke(ctx, "/api.RpcNode/GetConsensusStateJSON", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcNodeClient) GetConsensusValidators(ctx context.Context, in *consensus.GetConsensusStatusRequest, opts ...grpc.CallOption) (*consensus.Validators, error) {
	out := new(consensus.Validators)
	err := c.cc.Invoke(ctx, "/api.RpcNode/GetConsensusValidators", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcNodeClient) GetConsensusHeight(ctx context.Context, in *consensus.GetConsensusStatusRequest, opts ...grpc.CallOption) (*wrapperspb.UInt64Value, error) {
	out := new(wrapperspb.UInt64Value)
	err := c.cc.Invoke(ctx, "/api.RpcNode/GetConsensusHeight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rpcNodeClient) GetSyncState(ctx context.Context, in *sync.GetSyncStateRequest, opts ...grpc.CallOption) (*sync.SyncState, error) {
	out := new(sync.SyncState)
	err := c.cc.Invoke(ctx, "/api.RpcNode/GetSyncState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RpcNodeServer is the server API for RpcNode service.
type RpcNodeServer interface {
	// processing transaction message requests
	SendRequest(context.Context, *common.TxRequest) (*common.TxResponse, error)
	// processing transaction message requests in sync mode.
	// returns tx execution result
	SendRequestSync(context.Context, *common.TxRequest) (*common.TxResponse, error)
	// processing requests for message subscription
	Subscribe(*common.TxRequest, RpcNode_SubscribeServer) error
	// processing requests for message subscription by websocket
	SubscribeWS(*common.RawTxRequest, RpcNode_SubscribeWSServer) error
	// update debug status (development debugging)
	UpdateDebugConfig(context.Context, *config.DebugConfigRequest) (*config.DebugConfigResponse, error)
	// refreshLogLevelsConfig
	RefreshLogLevelsConfig(context.Context, *config.LogLevelsRequest) (*config.LogLevelsResponse, error)
	// get techtradechain version
	GetTechTradeChainVersion(context.Context, *config.TechTradeChainVersionRequest) (*config.TechTradeChainVersionResponse, error)
	// check chain configuration and load new chain dynamically
	CheckNewBlockChainConfig(context.Context, *config.CheckNewBlockChainConfigRequest) (*config.CheckNewBlockChainConfigResponse, error)
	// GetPoolStatus Returns the max size of config transaction pool and common transaction pool,
	// the num of config transaction in queue and pendingCache,
	// and the the num of common transaction in queue and pendingCache.
	GetPoolStatus(context.Context, *txpool.GetPoolStatusRequest) (*txpool.TxPoolStatus, error)
	// GetTxIdsByTypeAndStage Returns config or common txIds in different stage.
	// TxType may be TxType_CONFIG_TX, TxType_COMMON_TX, (TxType_CONFIG_TX|TxType_COMMON_TX)
	// TxStage may be TxStage_IN_QUEUE, TxStage_IN_PENDING, (TxStage_IN_QUEUE|TxStage_IN_PENDING)
	GetTxIdsByTypeAndStage(context.Context, *txpool.GetTxIdsByTypeAndStageRequest) (*txpool.GetTxIdsByTypeAndStageResponse, error)
	// GetTxsInPoolByTxIds Retrieve the transactions by the txIds from the txPool,
	// return transactions in the txPool and txIds not in txPool.
	// default query upper limit is 1w transaction, and error is returned if the limit is exceeded.
	GetTxsInPoolByTxIds(context.Context, *txpool.GetTxsInPoolByTxIdsRequest) (*txpool.GetTxsInPoolByTxIdsResponse, error)
	// GetConsensusStateJSON query the state of the consensus,
	// return the consensus status after JSON serialization, including consensus nodes, heights, and views.
	GetConsensusStateJSON(context.Context, *consensus.GetConsensusStatusRequest) (*wrapperspb.BytesValue, error)
	// GetConsensusValidators Gets the consensus node list
	GetConsensusValidators(context.Context, *consensus.GetConsensusStatusRequest) (*consensus.Validators, error)
	// GetConsensusHeight Gets the height of the block that the node is currently agreeing on
	GetConsensusHeight(context.Context, *consensus.GetConsensusStatusRequest) (*wrapperspb.UInt64Value, error)
	// GetSyncState get state of sync module
	GetSyncState(context.Context, *sync.GetSyncStateRequest) (*sync.SyncState, error)
}

// UnimplementedRpcNodeServer can be embedded to have forward compatible implementations.
type UnimplementedRpcNodeServer struct {
}

func (*UnimplementedRpcNodeServer) SendRequest(ctx context.Context, req *common.TxRequest) (*common.TxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendRequest not implemented")
}
func (*UnimplementedRpcNodeServer) SendRequestSync(ctx context.Context, req *common.TxRequest) (*common.TxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendRequestSync not implemented")
}
func (*UnimplementedRpcNodeServer) Subscribe(req *common.TxRequest, srv RpcNode_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (*UnimplementedRpcNodeServer) SubscribeWS(req *common.RawTxRequest, srv RpcNode_SubscribeWSServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeWS not implemented")
}
func (*UnimplementedRpcNodeServer) UpdateDebugConfig(ctx context.Context, req *config.DebugConfigRequest) (*config.DebugConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDebugConfig not implemented")
}
func (*UnimplementedRpcNodeServer) RefreshLogLevelsConfig(ctx context.Context, req *config.LogLevelsRequest) (*config.LogLevelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshLogLevelsConfig not implemented")
}
func (*UnimplementedRpcNodeServer) GetTechTradeChainVersion(ctx context.Context, req *config.TechTradeChainVersionRequest) (*config.TechTradeChainVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTechTradeChainVersion not implemented")
}
func (*UnimplementedRpcNodeServer) CheckNewBlockChainConfig(ctx context.Context, req *config.CheckNewBlockChainConfigRequest) (*config.CheckNewBlockChainConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckNewBlockChainConfig not implemented")
}
func (*UnimplementedRpcNodeServer) GetPoolStatus(ctx context.Context, req *txpool.GetPoolStatusRequest) (*txpool.TxPoolStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPoolStatus not implemented")
}
func (*UnimplementedRpcNodeServer) GetTxIdsByTypeAndStage(ctx context.Context, req *txpool.GetTxIdsByTypeAndStageRequest) (*txpool.GetTxIdsByTypeAndStageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTxIdsByTypeAndStage not implemented")
}
func (*UnimplementedRpcNodeServer) GetTxsInPoolByTxIds(ctx context.Context, req *txpool.GetTxsInPoolByTxIdsRequest) (*txpool.GetTxsInPoolByTxIdsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTxsInPoolByTxIds not implemented")
}
func (*UnimplementedRpcNodeServer) GetConsensusStateJSON(ctx context.Context, req *consensus.GetConsensusStatusRequest) (*wrapperspb.BytesValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsensusStateJSON not implemented")
}
func (*UnimplementedRpcNodeServer) GetConsensusValidators(ctx context.Context, req *consensus.GetConsensusStatusRequest) (*consensus.Validators, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsensusValidators not implemented")
}
func (*UnimplementedRpcNodeServer) GetConsensusHeight(ctx context.Context, req *consensus.GetConsensusStatusRequest) (*wrapperspb.UInt64Value, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsensusHeight not implemented")
}
func (*UnimplementedRpcNodeServer) GetSyncState(ctx context.Context, req *sync.GetSyncStateRequest) (*sync.SyncState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSyncState not implemented")
}

func RegisterRpcNodeServer(s *grpc.Server, srv RpcNodeServer) {
	s.RegisterService(&_RpcNode_serviceDesc, srv)
}

func _RpcNode_SendRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.TxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcNodeServer).SendRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.RpcNode/SendRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcNodeServer).SendRequest(ctx, req.(*common.TxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcNode_SendRequestSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.TxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcNodeServer).SendRequestSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.RpcNode/SendRequestSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcNodeServer).SendRequestSync(ctx, req.(*common.TxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcNode_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(common.TxRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RpcNodeServer).Subscribe(m, &rpcNodeSubscribeServer{stream})
}

type RpcNode_SubscribeServer interface {
	Send(*common.SubscribeResult) error
	grpc.ServerStream
}

type rpcNodeSubscribeServer struct {
	grpc.ServerStream
}

func (x *rpcNodeSubscribeServer) Send(m *common.SubscribeResult) error {
	return x.ServerStream.SendMsg(m)
}

func _RpcNode_SubscribeWS_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(common.RawTxRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RpcNodeServer).SubscribeWS(m, &rpcNodeSubscribeWSServer{stream})
}

type RpcNode_SubscribeWSServer interface {
	Send(*common.SubscribeResult) error
	grpc.ServerStream
}

type rpcNodeSubscribeWSServer struct {
	grpc.ServerStream
}

func (x *rpcNodeSubscribeWSServer) Send(m *common.SubscribeResult) error {
	return x.ServerStream.SendMsg(m)
}

func _RpcNode_UpdateDebugConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(config.DebugConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcNodeServer).UpdateDebugConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.RpcNode/UpdateDebugConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcNodeServer).UpdateDebugConfig(ctx, req.(*config.DebugConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcNode_RefreshLogLevelsConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(config.LogLevelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcNodeServer).RefreshLogLevelsConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.RpcNode/RefreshLogLevelsConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcNodeServer).RefreshLogLevelsConfig(ctx, req.(*config.LogLevelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcNode_GetTechTradeChainVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(config.TechTradeChainVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcNodeServer).GetTechTradeChainVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.RpcNode/GetTechTradeChainVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcNodeServer).GetTechTradeChainVersion(ctx, req.(*config.TechTradeChainVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcNode_CheckNewBlockChainConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(config.CheckNewBlockChainConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcNodeServer).CheckNewBlockChainConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.RpcNode/CheckNewBlockChainConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcNodeServer).CheckNewBlockChainConfig(ctx, req.(*config.CheckNewBlockChainConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcNode_GetPoolStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(txpool.GetPoolStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcNodeServer).GetPoolStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.RpcNode/GetPoolStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcNodeServer).GetPoolStatus(ctx, req.(*txpool.GetPoolStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcNode_GetTxIdsByTypeAndStage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(txpool.GetTxIdsByTypeAndStageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcNodeServer).GetTxIdsByTypeAndStage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.RpcNode/GetTxIdsByTypeAndStage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcNodeServer).GetTxIdsByTypeAndStage(ctx, req.(*txpool.GetTxIdsByTypeAndStageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcNode_GetTxsInPoolByTxIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(txpool.GetTxsInPoolByTxIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcNodeServer).GetTxsInPoolByTxIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.RpcNode/GetTxsInPoolByTxIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcNodeServer).GetTxsInPoolByTxIds(ctx, req.(*txpool.GetTxsInPoolByTxIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcNode_GetConsensusStateJSON_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(consensus.GetConsensusStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcNodeServer).GetConsensusStateJSON(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.RpcNode/GetConsensusStateJSON",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcNodeServer).GetConsensusStateJSON(ctx, req.(*consensus.GetConsensusStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcNode_GetConsensusValidators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(consensus.GetConsensusStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcNodeServer).GetConsensusValidators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.RpcNode/GetConsensusValidators",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcNodeServer).GetConsensusValidators(ctx, req.(*consensus.GetConsensusStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcNode_GetConsensusHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(consensus.GetConsensusStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcNodeServer).GetConsensusHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.RpcNode/GetConsensusHeight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcNodeServer).GetConsensusHeight(ctx, req.(*consensus.GetConsensusStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RpcNode_GetSyncState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(sync.GetSyncStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RpcNodeServer).GetSyncState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.RpcNode/GetSyncState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RpcNodeServer).GetSyncState(ctx, req.(*sync.GetSyncStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RpcNode_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.RpcNode",
	HandlerType: (*RpcNodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendRequest",
			Handler:    _RpcNode_SendRequest_Handler,
		},
		{
			MethodName: "SendRequestSync",
			Handler:    _RpcNode_SendRequestSync_Handler,
		},
		{
			MethodName: "UpdateDebugConfig",
			Handler:    _RpcNode_UpdateDebugConfig_Handler,
		},
		{
			MethodName: "RefreshLogLevelsConfig",
			Handler:    _RpcNode_RefreshLogLevelsConfig_Handler,
		},
		{
			MethodName: "GetTechTradeChainVersion",
			Handler:    _RpcNode_GetTechTradeChainVersion_Handler,
		},
		{
			MethodName: "CheckNewBlockChainConfig",
			Handler:    _RpcNode_CheckNewBlockChainConfig_Handler,
		},
		{
			MethodName: "GetPoolStatus",
			Handler:    _RpcNode_GetPoolStatus_Handler,
		},
		{
			MethodName: "GetTxIdsByTypeAndStage",
			Handler:    _RpcNode_GetTxIdsByTypeAndStage_Handler,
		},
		{
			MethodName: "GetTxsInPoolByTxIds",
			Handler:    _RpcNode_GetTxsInPoolByTxIds_Handler,
		},
		{
			MethodName: "GetConsensusStateJSON",
			Handler:    _RpcNode_GetConsensusStateJSON_Handler,
		},
		{
			MethodName: "GetConsensusValidators",
			Handler:    _RpcNode_GetConsensusValidators_Handler,
		},
		{
			MethodName: "GetConsensusHeight",
			Handler:    _RpcNode_GetConsensusHeight_Handler,
		},
		{
			MethodName: "GetSyncState",
			Handler:    _RpcNode_GetSyncState_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _RpcNode_Subscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeWS",
			Handler:       _RpcNode_SubscribeWS_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/rpc_node.proto",
}
